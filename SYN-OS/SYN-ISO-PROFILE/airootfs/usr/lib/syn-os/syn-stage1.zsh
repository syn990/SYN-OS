#!/bin/zsh
# SYN-OS Stage 1: configure system, bootloader, users
# /usr/lib/syn-os/syn-stage1.zsh

# This is the second stage of the SYN-OS installation process, executed within the chroot environment after the base system has been set up by Stage 0. It configures system settings such as locale, hostname, timezone, and console. 
# It also sets up the bootloader based on the partitioning strategy used in Stage 0, and creates a user account with sudo/doas privileges.
# The script relies on the state file generated by Stage 0 to determine the configuration and devices to work with. It also ensures that the initramfs is properly configured for the chosen volume management strategy (LUKS, LVM, etc.) and that the appropriate hooks are included.

set -euo pipefail

# Load config + UI
source /usr/lib/syn-os/syn-config.zsh
source /usr/lib/syn-os/ui.zsh

# Load derived state from Stage 0
State="/etc/syn-os/install.state"
if [ -r "$State" ]; then
  source "$State"
else
  echo "ERROR: Missing install.state at $State"
  exit 1
fi

echo "SYN-OS Stage 1 â€” ${PartitionStrat} + ${VolumeStrat}"
echo "ROOT device: ${RootFsDev}"
echo "SWAP: ${SwapDev:-none}"
echo "LUKS: ${LuksUuid:+yes}${LuksUuid:-no}"

# Locale / Hostname / Time / Console configuration based on state from Stage 0. This ensures that the installed system has the correct locale settings, hostname, timezone, and console configuration (keymap and font) as specified by the user during the installation process.
# These values cam also be properly modified in /etc/syn-os/synos.conf before running 'synos-install' if you want to change them before Stage 0.
echo "$LocaleGen" > /etc/locale.gen
locale-gen
echo "LANG=$Locale" > /etc/locale.conf
echo "$Hostname" > /etc/hostname

if [ -e "/usr/share/zoneinfo/$TimeZone" ]; then
  ln -sf "/usr/share/zoneinfo/$TimeZone" /etc/localtime
else
  ln -sf "/usr/share/zoneinfo/Europe/London" /etc/localtime
fi

printf "KEYMAP=%s\nFONT=%s\n" "$KeyMap" "$VconsoleFont" > /etc/vconsole.conf
hwclock --systohc

# doas + sudo shim setup 
if command -v doas >/dev/null 2>&1; then
  echo "permit persist :wheel" > /etc/doas.conf
  chmod 600 /etc/doas.conf
  printf '#!/bin/sh\nexec doas "$@"\n' > /usr/bin/sudo
  chmod 755 /usr/bin/sudo
  pacman -Rdd --noconfirm sudo 2>/dev/null || true
fi

# User account setup
: "${UserAccountName:?UserAccountName not set}"
if ! id -u "$UserAccountName" >/dev/null 2>&1; then
  useradd -m -G wheel -s "$UserShell" "$UserAccountName"
fi
echo "Set password for $UserAccountName:"
passwd "$UserAccountName" </dev/tty

# System overlays deployed during pacstrap

# mkinitcpio: Use traditional hooks for both UEFI and BIOS
configure_mkinitcpio() {
  HOOKS=(base udev autodetect modconf kms keyboard keymap consolefont block)
  if [[ "$VolumeStrat" == luks* ]]; then
    HOOKS+=(encrypt)
  fi
  if [[ "$VolumeStrat" == *lvm* ]]; then
    HOOKS+=(lvm2)
  fi
  HOOKS+=(filesystems fsck)

  echo "Configuring mkinitcpio with HOOKS: ${HOOKS[*]}"
  sed -i "s/^HOOKS=.*/HOOKS=(${HOOKS[*]})/" /etc/mkinitcpio.conf
}

# Regenerate initramfs with new hooks and configs to ensure proper booting with the chosen volume strategy
# This is especially important for LUKS setups to ensure the initramfs includes the necessary tools and hooks to prompt for the passphrase and unlock the root filesystem at boot.
# Other volume strategies (like plain partitions or LVM without encryption) may not strictly require custom hooks, but regenerating the initramfs ensures that any changes to the system configuration are properly reflected in the boot process.
configure_mkinitcpio
mkinitcpio -P

# Bootloader configuration
RootCmdline=""
if [[ "$VolumeStrat" == luks* ]]; then
  RootCmdline="cryptdevice=UUID=${LuksUuid}:${LuksLabel} root=${RootFsDev} rw"
else
  if RootUuidPrint="$(blkid -s UUID -o value "$RootFsDev" 2>/dev/null || true)"; then
    RootCmdline="root=UUID=${RootUuidPrint} rw"
  else
    RootCmdline="root=${RootFsDev} rw"
  fi
fi

ResumeOpt=""
if [ -n "${SwapDev:-}" ]; then
  if SwapUuidPrint="$(blkid -s UUID -o value "$SwapDev" 2>/dev/null || true)"; then
    ResumeOpt="resume=UUID=${SwapUuidPrint}"
  fi
fi

# Bootloader installation if using syslinux or systemd-boot. If using systemd-boot, also create a loader entry for the new system with the appropriate kernel parameters.
# For UEFI systems with systemd-boot
if [ "$PartitionStrat" = "uefi-bootctl" ]; then
  bootctl --path=/boot install
  mkdir -p /boot/loader/entries
  cat > /boot/loader/loader.conf <<'EOF'
default syn.conf
timeout 0
editor  0
EOF

  INITRD_LINES="initrd  /initramfs-linux.img"
  [ -f /boot/intel-ucode.img ] && INITRD_LINES="initrd  /intel-ucode.img\n$INITRD_LINES"
  [ -f /boot/amd-ucode.img ] && INITRD_LINES="initrd  /amd-ucode.img\n$INITRD_LINES"

  cat > /boot/loader/entries/syn.conf <<EOF
title   SYN-OS
linux   /vmlinuz-linux
${INITRD_LINES}
options ${RootCmdline} ${ResumeOpt} vconsole.keymap=${KeyMap} ${KernelOpts}
EOF
# For BIOS systems with syslinux on MBR-partitioned disks
elif [ "$PartitionStrat" = "mbr-syslinux" ]; then
  syslinux-install_update -i -a -m || true
  if [ -f /boot/syslinux/syslinux.cfg ]; then
    sed -i "s|APPEND .*|APPEND ${RootCmdline} ${ResumeOpt} vconsole.keymap=${KeyMap} ${KernelOpts}|" /boot/syslinux/syslinux.cfg
  fi
else
  echo "ERROR: Unsupported PartitionStrat '$PartitionStrat'"
  exit 1
fi

# Enable baseline services
systemctl enable dhcpcd.service 2>/dev/null || true
systemctl enable iwd.service    2>/dev/null || true

# Finalize installation and prompt for reboot
syn_ui::final_banner
